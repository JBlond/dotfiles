#!/usr/bin/env bash
set -euo pipefail
exec 9>/var/lock/backup-zfs.lock
flock -n 9 || die 1 "another instance already running"
IFS=$'\n\t'
# backup-zfs: use zfs send/recv to push/pull snapshots
prog="$(basename "$0")"

usage() {
	cat >&2 <<-EOF
	usage: $prog [-hvq] [-t tag] [-k keep] [-d dateopts] src dest
	  use zfs send/recv to push/pull snapshots

	  src          the source fs, specified as [host:]pool/path/to/fs
	  dest         the destination fs parent, specified as [host:]pool/path/to/fs
	               (the final path component of src will be appended to dest)
	  -p           ssh port
	  -h           help
	  -v           verbose mode
	  -q           quiet mode
	  -t tag       tag to use for naming snapshots (default: backup-zfs)
	  -k keep      number of snapshots to keep on src (default: 5)
	  -d dateopts  options for date(1) - used to name the snapshots (default: +%F_%T)

	  # Local mode: Backup tank/system to backup/tank/system
	  backup-zfs tank/system backup/tank

	  # Pull mode: Backup tank/system on tankhost to localhost
	  backup-zfs tankhost:tank/system backup/tank

	  # Push mode: Backup tank/system on localhost to backuphost
	  backup-zfs tank/system backuphost:backup/tank

	  # Double remote mode: Backup tank/system on tankhost to backuphost
	  backup-zfs tankhost:tank/system backuphost:backup/tank

	  # In this mode, your client will establish two separate SSH sessions,
	  # connect them with a pipe, and pull data from one while pushing to the
	  # other. No data will be stored locally.
	EOF
	exit "$1"
}

# log to syslog; if verbose or on a tty, also to stdout
# usage: log msg
log() {
	ts="$(date '+%F %T')"
	logger -t "$prog" -- "$@"
	if ! $quiet && { [[ -t 1 ]] || $verbose; }; then
		echo "[$ts] $@" >&2
	fi
}

# exit with a code & message
# usage: die $exitcode msg
die() {
	code="$1"
	shift
	if [[ $code -ne 0 ]] ; then
		verbose=true log "FATAL: $*"
	else
		log "$@"
	fi
	exit "$code"
}

# run zfs(1) command either locally or via ssh
# usage: ZFS "$host" command args...
ZFS() {
	host="$1"
	shift

	local cmd=(zfs "$@")

	if [[ -n $host ]] ; then
		log "remote ($host): ${cmd[*]}"
		ssh -C -p "$port" "$host" "${cmd[@]}"
	else
		log "local: ${cmd[*]}"
		"${cmd[@]}"
	fi
}

###
### defaults
###
tag="$prog"
dateopts="+%F_%T"
keep=5
verbose=false
quiet=false
port=22
send_opts=""
recv_opts=""

###
### parse options
###
while getopts "hvqk:p:t:d:" opt ; do
	case $opt in
		h) usage 0 ;;
		v)
			verbose=true
			send_opts="-v"
			recv_opts="-v"
			;;
		q) quiet=true ;;
		k) keep=$OPTARG ;;
		p) port=$OPTARG ;;
		t) tag=$OPTARG ;;
		d) dateopts=$OPTARG ;;
		*) usage 1 ;;
	esac
done
shift $((OPTIND-1))
date="$(date "$dateopts")"

###
### parse src & dest host/fs info
###
# fail if there's ever >1 colon
if [[ $1 =~ :.*: || $2 =~ :.*: ]] ; then
	die 1 "invalid fsspec: '$1' or '$2'"
fi

# fail if src or dest isn't specified
if [[ -z $1 || -z $2 ]] ; then
	usage 1
fi
src="$1"
dest="$2"

# discard anything before a colon to get the fs
srcfs="${src#*:}"
destfs="${dest#*:}"

# if there is a colon, discard everything after it to get the host
srchost=""
desthost=""
[[ $src =~ : ]] && srchost="${src%:*}"
[[ $dest =~ : ]] && desthost="${dest%:*}"

# get the last src component
srcbase="${srcfs##*/}"

# ensure the destination fs exists before proceeding
if [[ $(ZFS "$desthost" list -H -o name "$destfs" 2>/dev/null) != "$destfs" ]] ; then
	die 1 "destination fs '$destfs' doesn't exist â˜ ï¸"
fi

###
### resume token support (before creating new snapshot)
###
resume_token="$(
	ZFS "$desthost" get -H -o value receive_resume_token "$destfs/$srcbase" 2>/dev/null | tr -d '[:space:]'
)"

if [[ -n "$resume_token" && "$resume_token" != "-" ]]; then
	log "found resume token for $destfs/$srcbase"

	# test if dataset existists
	if ! ZFS "$desthost" list "$destfs/$srcbase" >/dev/null 2>&1 ; then
		die 1 "resume token exists but dataset $destfs/$srcbase does not exist"
	fi

	# test token is valid
	if ! ZFS "$srchost" send -nvt "$resume_token" >/dev/null 2>&1 ; then
		die 1 "resume token is invalid or incompatible with current source dataset"
	fi

	log "resuming interrupted zfs send/receive operation"
	if ZFS "$srchost" send -t "$resume_token" | ZFS "$desthost" receive $recv_opts -F -u -e "$destfs" ; then
		log "resume completed successfully"
		exit
	else
		die 1 "resume failed"
	fi
fi

###
### create new snapshot on src
###
cur="$srcfs@${tag}_$date"
ZFS "$srchost" snapshot -r "$cur" || die $? "zfs snapshot failed â˜ ï¸"

###
### get newest snapshot on dest - it must exist on src
### (only snapshots with fitting Tag)
###
last="$(
	ZFS "$desthost" list -d 1 -t snapshot -H -S creation -o name "$destfs/$srcbase" 2>/dev/null \
		| grep "@${tag}_" \
		| head -n1 \
		| cut -f2 -d@
)"

###
### send & receive
###
# 1st time: send full snapshot
if [[ -z $last ]] ; then
	log "sending full recursive snapshot from $src to $dest"
	ZFS "$srchost" send "$send_opts" --raw -R "$cur" | ZFS "$desthost" receive $recv_opts -F -u -e "$destfs" || die $? "zfs full send failed â˜ ï¸"
# special case: tagged snapshots exist on dest, but src has rotated through all
elif ! ZFS "$srchost" list "$srcfs"@"$last" &>/dev/null ; then
	log "no incremental path found ðŸ’© - falling back to full send"
	last=""
# normal case: send incremental
else
	log "sending incremental snapshot from $src to $dest (${last#"${tag}"_}..${cur#*@"${tag}"_})"
	ZFS "$srchost" send "$send_opts" --raw -R -I "$last" "$cur" | ZFS "$desthost" receive $recv_opts -F -u -e "$destfs" || die $? "zfs incremental send failed"
fi

###
### clean up old snapshots
###
for snap in $(ZFS "$srchost" list -d 1 -t snapshot -H -S creation -o name "$srcfs" \
		| grep -F "@${tag}_" | cut -f2 -d@ | tail -n+$((keep+1)) ) ;
do
	ZFS "$srchost" destroy -r "$srcfs"@"$snap"
	log "destroying old snapshot srchost : $snap"
done
