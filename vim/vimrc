set nocompatible

if has('win32') || has('win64')
    source $VIMRUNTIME/mswin.vim
endif

:set hidden                                  " allow buffer
" set viminfo^=%                             " remember my buffers

set encoding=utf-8                           " always use utf-8
set ruler                                    " Always show cursor position.
set nu                                       " Show line numbers on the sidebar.
set nowrap                                   " no wrapping
set nobackup                                 " no *~ backup files
set cursorline                               " Highlight current line

set tabstop=4                                " tabstop length 4
set shiftwidth=4                             "
set autoindent                               " enable autoindent
set smartindent                              " enable smart indent
set copyindent                               "
set shortmess=atI                            " Don't show the intro message when starting vim
set noshowmode                               " done by plugin https://github.com/itchyny/lightline.vim
set wildmenu                                 " Enhanced command line completion.
set wildmode=list:longest,longest:full       " Complete files like a shell.
set showcmd                                  " Show partial commands in the last line of the screen
set laststatus=2                             " Always display the status line, even if only one window is displayed
set confirm                                  " nicer dialog when closing with unsaved changes
set visualbell                               " Use visual bell instead of beeping when doing something wrong
set t_vb=                                    " reset the terminal code for the visual bell.
set mouse=a                                  " Enable use of the mouse for all modes
set pastetoggle=<F11>                        " Use <F11> to toggle between 'paste' and 'nopaste'
nnoremap <C-L> :nohl<CR><C-L>                " Map <C-L> (redraw screen) to also turn off search highlighting until the next search

syntax on                                    " syntax highlighting on
set bg=dark                                  " Dark Background
colorscheme monokai                          " my colorscheme

set ignorecase                               " search case-insensitive
set smartcase                                " Automatically switch search to case-sensitive when search query contains an uppercase letter.
set infercase                                "
set incsearch                                " Highlight matches as you type.
set hlsearch                                 " Highlight matches.
set wildignore+=*.o,*.obj,*.exe,*.so,*.dll,*.pyc,.svn,.hg,.bzr,.git,.sass-cache,*.class,node_modules
set path+=**                                 " search down into subfolders

set nostartofline
set showmatch                                " Show matching brackets.
set matchtime=2                              " How many tenths of a second to blink
set list                                     " show tab and trail
set listchars=tab:»»,trail:·,extends:>,precedes:<,eol:↲

" highlight ColorColumn ctermbg=yellow         " Show a line after 80 characters
" call matchadd('ColorColumn', '\%81v', 100)

set directory=~/.vim/swaps                   " Local dirs (centralize everything)


map <C-p> :bprevious<CR>                     " move among buffers with CTRL + p (previous)
map <C-n> :bnext<CR>                         " move among buffers with CTRL + n (next)

" short resize with + and -
if bufwinnr(1)
    map + <C-W>+
    map - <C-W>-
endif

let g:bufferline_echo = 0

let g:lightline = {
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'readonly', 'modified', 'gitbranch' ], [ 'bufferline' ]
    \           ]
    \ },
    \ 'component_function': {
        \   'bufferline': 'MyBufferline',
        \	'gitbranch': 'gitbranch#name'
    \ }
\ }

function! MyBufferline()
    call bufferline#refresh_status()
    let b = g:bufferline_status_info.before
    let c = g:bufferline_status_info.current
    let a = g:bufferline_status_info.after
    let alen = strlen(a)
    let blen = strlen(b)
    let clen = strlen(c)
    let w = winwidth(0) * 4 / 11
    if w < alen+blen+clen
        let whalf = (w - strlen(c)) / 2
        let aa = alen > whalf && blen > whalf ? a[:whalf] : alen + blen < w - clen || alen < whalf ? a : a[:(w - clen - blen)]
        let bb = alen > whalf && blen > whalf ? b[-(whalf):] : alen + blen < w - clen || blen < whalf ? b : b[-(w - clen - alen):]
        return (strlen(bb) < strlen(b) ? '...' : '') . bb . c . aa . (strlen(aa) < strlen(a) ? '...' : '')
    else
        return b . c . a
endif
endfunction

execute pathogen#infect()
filetype plugin indent on

let g:netrw_liststyle=3                      " tree view
let g:netrw_list_hide=netrw_gitignore#Hide()
let g:netrw_list_hide.=',\(^\|\s\s\)\zs\.\S\+'

command W w !sudo tee % > /dev/null          " :W sudo saves the file (useful for handling the permission-denied error)

autocmd BufNewFile,BufRead *.conf set syntax=apache
